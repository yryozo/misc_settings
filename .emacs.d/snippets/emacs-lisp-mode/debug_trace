 -*-*- coding: utf-8; mode: snippet -*-*-
# name: debug(デバッグ), trace(トレース), 
# --
;;; エラー時にデバッガが開くようにする
;; (デバッガからは, 各関数の定義場所に飛んだり, 各関数の説明を見たりすることが可能)
;; 
; (setq debug-on-error t) ; 設定を有効化
; (toggle-debug-on-error) ; 設定をトグル

;;; バイトコンパイルされたせいで定義箇所に飛べない関数があれば, 
;;; load で明示的に el ファイルを読み直せばいい.
;; 
; (load "anything.el")

;;; 関数のトレースを取りたい場合は, trace-function で関数を指定すればいい
;;; (以後の呼び出し時に, 自動的にトレースが出力されるようになる)
; (trace-function 'ac-start)
;;
;;; トレースが不要になったら, untrace-funcition で1つずつ解除可能.
;;; あるいは untrace-all で一括で解除可能.
; (untrace-all)

;;; 本格的なデバッグには edebug (elisp 用のデバッガ) が便利.
;; 1. ブレークポイントなどを指定したい関数の定義箇所に移動する.
;; 2. その関数に対して edebug を有効にする.
;;    (その関数の中で C-u C-M-x. 
;;     これで, edebug を有効にして関数を再定義する, ことができる)
;; 3. その関数が呼び出されると, 関数の先頭で停止する. 
;;    後はステップ実行などで追っていける.
;;    * Space : ステップ実行 (gdb の next 相当?)
;;    * i : ステップ実行. 関数呼び出し時には中まで入る
;;    * 関数内の適当な式にカーソルを合わせて h : その式の箇所まで一気に実行
;;    * c : ブレークポイントまで一気に実行. 
;;          なおブレークポイントを入れるには, 関数中の止めたい箇所に (edebug) という式を埋め込めばいい.
;;          オリジナルのファイルを書き換えるのが嫌なら, 関数定義を *scratch* あたりにコピーしてくればいい.
;;    * e : 現在のコンテキストで式を評価
;;    * E : 評価リストを編集 (このリスト中の式は毎回止まる度に評価される. 毎回 e で値を見る手間が省ける. 編集したら C-c C-u で登録)
